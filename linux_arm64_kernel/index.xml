<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux_arm64_kernel on Test1234가나다라</title>
    <link>https://prifri.github.io/linux_arm64_kernel/</link>
    <description>Recent content in Linux_arm64_kernel on Test1234가나다라</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 24 Aug 2021 17:48:25 +0900</lastBuildDate>
    
	<atom:link href="https://prifri.github.io/linux_arm64_kernel/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cache</title>
      <link>https://prifri.github.io/linux_arm64_kernel/arch/cache/</link>
      <pubDate>Tue, 24 Aug 2021 17:48:25 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/arch/cache/</guid>
      <description>참고사이트 문c블로그 Cache-Coherent
 WB(Write-Back)   Write
 Cache에만 Write. cache가 가득 찻을때만 Memory에 Write    Read
 Cache에서만 읽음     WT(Write-Through)   Write
 Cache, Memory 둘다 Write    Read
 Cache에서만 읽음     WA, RA(Write-Allocate, Read-Allocate) Write시 Cache에 해당 메모리가 없을때(Miss발생시) Cache에 해당 메모리의 데이터를 Cache에 할당하고 할당된 캐시에 데이터를 기록한다. Read또한 마찬가지로 read시 cache에 없으면 cache에 할당한다.</description>
    </item>
    
    <item>
      <title>TCR</title>
      <link>https://prifri.github.io/linux_arm64_kernel/arch/TCR/</link>
      <pubDate>Tue, 24 Aug 2021 16:56:42 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/arch/TCR/</guid>
      <description>TXSZ 가상주소를 계산할때 상위 주소의 0, 1의 개수를 미리 설정해놓는것이다. Kernel 공간 인경우 상위 비트가 1이 채워져있는 개념이므로 T1SZ을 사용하게 되고 user 공간 인경우 상위 비트가 0이 채워져있는 개념이므로 T0SZ을 사용하게 된다.
 T0SZ User 공간의 가상주소에서 주소 하위에서부터 0이 채워지는 비트 개수
 T0SZ = 16일때 0x0000_ABCD_ABCD_ABCD__ABCD_ABCD_ABCD   T1SZ Kernel 공간의 가상주소에서 주소 상위에서부터 1이 채워지는 비트 개수
 T1SZ = 16일때 0xFFFF_ABCD_ABCD_ABCD__ABCD_ABCD_ABCD_ABCD   특성  TXSZ가 커짐에따라 해당 영역의 가상주소공간이 줄어듬을 알 수 있다.</description>
    </item>
    
    <item>
      <title>Ifb</title>
      <link>https://prifri.github.io/linux_arm64_kernel/assembly/ifb/</link>
      <pubDate>Fri, 20 Aug 2021 18:05:58 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/assembly/ifb/</guid>
      <description>[ifb 참고] (https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/useful-assembler-directives-and-macros-for-the-gnu-assembler)
 .macro	ldr_l, dst, sym, tmp= .ifb	\tmp adrp	\dst, \sym ldr	\dst, [\dst, :lo12:\sym] .else adrp	\tmp, \sym ldr	\dst, [\tmp, :lo12:\sym] .endif .endm .ifb = if blank라는 뜻
ldr_l	x4, idmap_ptrs_per_pgd 이런 코드가 왔으면 위 macro에서 ifb 로 된 code가 만들어질것이다. </description>
    </item>
    
    <item>
      <title>DC</title>
      <link>https://prifri.github.io/linux_arm64_kernel/instruction/dc/</link>
      <pubDate>Fri, 20 Aug 2021 17:39:47 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/instruction/dc/</guid>
      <description>data cache 의 invalidate / clean 관련 명령어
 cache invalidate한다 라는 의미는? cache clean한다 라는 의미는? dirty bit가 set된 cache를 모두 메모리에 반영한다는것.
dc ivac, Xt D-cache invalidate by address to Point of Coherency
dc instruction option에 대한 설명   dc : Data Cache
  IC : Instruction Cache
  IS : Inner Shareable
  ALL : all
  U : Point of Unification</description>
    </item>
    
    <item>
      <title>DMB</title>
      <link>https://prifri.github.io/linux_arm64_kernel/instruction/dmb/</link>
      <pubDate>Fri, 20 Aug 2021 17:30:28 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/instruction/dmb/</guid>
      <description>해당 instruction을 기준으로 명령의 순서를 변경하지 않는다.
 dmb sy Ordered Accesses : Any - Any
store / load가 전부 완료될때까지 기다리고 하겠다는뜻.
 </description>
    </item>
    
  </channel>
</rss>