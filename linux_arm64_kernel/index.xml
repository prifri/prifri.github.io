<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux_arm64_kernel on TestTitle</title>
    <link>https://prifri.github.io/linux_arm64_kernel/</link>
    <description>Recent content in Linux_arm64_kernel on TestTitle</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 26 Aug 2021 11:03:29 +0900</lastBuildDate>
    
	<atom:link href="https://prifri.github.io/linux_arm64_kernel/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Barrier</title>
      <link>https://prifri.github.io/linux_arm64_kernel/memory/barrier/</link>
      <pubDate>Thu, 26 Aug 2021 11:03:29 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/memory/barrier/</guid>
      <description>ISB(Instruction Synchronization Barrier) 파이프라인을 비워줌(15~20 cycle)
DMB(Data Memory Barrier) load, store의 순서를 유지해줌 + 모든 CPU에서 해당 값의 일관성을 유지 시켜줌.
DSB(Data Synchronization Barrier) Memory에 관련된 동기화</description>
    </item>
    
    <item>
      <title>Device_memory</title>
      <link>https://prifri.github.io/linux_arm64_kernel/memory/device_memory/</link>
      <pubDate>Wed, 25 Aug 2021 12:11:02 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/memory/device_memory/</guid>
      <description>Device Memory Normal Memory는 Cache를 사용할수있음. Device memory는 Buffer 개념임.
 Gathering(G or nG) 모아서 처리해도 되는지 안되는지에 대한 여부. 일반적으로 모아서 처리해도되지만 예를들어 Counter의 경우 이런 처리를 하면 안된다.
Reorder(R or nR) 순서를 지켜도 되는지 안되는지에 대한 여부.
Early Write Acknowledgement(E or nE) Write Done이 안됬어도 미리 Ack를 보낼지 안보낼지에 대한것.
메모리 Write는 Error가 안날 확률이 매우 높기떄문에 이렇게 처리한다는듯.
 ARM에서 사용하는 Device Type Device-nGnRnE. Stronlgy Ordered Memory. 다 안쓴다느듯.</description>
    </item>
    
    <item>
      <title>Cache</title>
      <link>https://prifri.github.io/linux_arm64_kernel/memory/cache/</link>
      <pubDate>Tue, 24 Aug 2021 17:48:25 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/memory/cache/</guid>
      <description>참고사이트 문c블로그 Cache-Coherent
 Cache Policies Cache Allocation Policies WA, RA(Write-Allocate, Read-Allocate)   Write시 Cache에 해당 메모리가 없을때(Miss발생시)
 Cache에 해당 메모리의 데이터를 할당. 할당된 캐시에 데이터를 기록한다.    Write시 Cache에 해당 메모리가 존재할때
 RAM에 접근하지않고 Cache에만 접근하고 끝날것이다.    cache data는 dirty, memory data는 old가 될것이다.
Read또한 마찬가지로 read시 cache에 없으면 cache에 할당한다.
꽤 많은 블로그에서 WA에대 잘못설명한다.
Cache에 할당하지 않고 바로 Memory에 Write 하기때문에 WT랑 같이 사용하지 않는다는둥, 대부분의 시스템에서는 WT nWA를 사용한다는둥.</description>
    </item>
    
    <item>
      <title>TCR</title>
      <link>https://prifri.github.io/linux_arm64_kernel/arch/TCR/</link>
      <pubDate>Tue, 24 Aug 2021 16:56:42 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/arch/TCR/</guid>
      <description>TXSZ 가상주소를 계산할때 상위 주소의 0, 1의 개수를 미리 설정해놓는것이다. Kernel 공간 인경우 상위 비트가 1이 채워져있는 개념이므로 T1SZ을 사용하게 되고 user 공간 인경우 상위 비트가 0이 채워져있는 개념이므로 T0SZ을 사용하게 된다.
 T0SZ User 공간의 가상주소에서 주소 하위에서부터 0이 채워지는 비트 개수
 T0SZ = 16일때 0x0000_ABCD_ABCD_ABCD__ABCD_ABCD_ABCD   T1SZ Kernel 공간의 가상주소에서 주소 상위에서부터 1이 채워지는 비트 개수
 T1SZ = 16일때 0xFFFF_ABCD_ABCD_ABCD__ABCD_ABCD_ABCD_ABCD   특성  TXSZ가 커짐에따라 해당 영역의 가상주소공간이 줄어듬을 알 수 있다.</description>
    </item>
    
    <item>
      <title>Ifb</title>
      <link>https://prifri.github.io/linux_arm64_kernel/assembly/ifb/</link>
      <pubDate>Fri, 20 Aug 2021 18:05:58 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/assembly/ifb/</guid>
      <description>ifb 참고
 .macro	ldr_l, dst, sym, tmp= .ifb	\tmp adrp	\dst, \sym ldr	\dst, [\dst, :lo12:\sym] .else adrp	\tmp, \sym ldr	\dst, [\tmp, :lo12:\sym] .endif .endm .ifb = if blank라는 뜻
ldr_l	x4, idmap_ptrs_per_pgd 이런 코드가 왔으면 위 macro에서 ifb 로 된 code가 만들어질것이다. </description>
    </item>
    
    <item>
      <title>DC</title>
      <link>https://prifri.github.io/linux_arm64_kernel/instruction/dc/</link>
      <pubDate>Fri, 20 Aug 2021 17:39:47 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/instruction/dc/</guid>
      <description>data cache 의 invalidate / clean 관련 명령어
 cache invalidate한다 라는 의미는? cache clean한다 라는 의미는? dirty bit가 set된 cache를 모두 메모리에 반영한다는것.
dc ivac, Xt D-cache invalidate by address to Point of Coherency
dc instruction option에 대한 설명   dc : Data Cache
  IC : Instruction Cache
  IS : Inner Shareable
  ALL : all
  U : Point of Unification</description>
    </item>
    
    <item>
      <title>DMB</title>
      <link>https://prifri.github.io/linux_arm64_kernel/instruction/dmb/</link>
      <pubDate>Fri, 20 Aug 2021 17:30:28 +0900</pubDate>
      
      <guid>https://prifri.github.io/linux_arm64_kernel/instruction/dmb/</guid>
      <description>해당 instruction을 기준으로 명령의 순서를 변경하지 않는다.
 dmb sy Ordered Accesses : Any - Any
store / load가 전부 완료될때까지 기다리고 하겠다는뜻.
 </description>
    </item>
    
  </channel>
</rss>