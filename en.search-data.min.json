[{"id":0,"href":"/linux_arm64_kernel/memory/barrier/","title":"Barrier","parent":"Linux_arm64_kernel","content":"ISB(Instruction Synchronization Barrier) 파이프라인을 비워줌(15~20 cycle)\nDMB(Data Memory Barrier) load, store의 순서를 유지해줌 + 모든 CPU에서 해당 값의 일관성을 유지 시켜줌.\nDSB(Data Synchronization Barrier) Memory에 관련된 동기화\n"},{"id":1,"href":"/linux_arm64_kernel/","title":"Linux_arm64_kernel","parent":"Test1234가나다라","content":""},{"id":2,"href":"/","title":"Test1234가나다라","parent":"","content":""},{"id":3,"href":"/linux_arm64_kernel/memory/device_memory/","title":"Device_memory","parent":"Linux_arm64_kernel","content":"Device Memory Normal Memory는 Cache를 사용할수있음. Device memory는 Buffer 개념임.\n Gathering(G or nG) 모아서 처리해도 되는지 안되는지에 대한 여부. 일반적으로 모아서 처리해도되지만 예를들어 Counter의 경우 이런 처리를 하면 안된다.\nReorder(R or nR) 순서를 지켜도 되는지 안되는지에 대한 여부.\nEarly Write Acknowledgement(E or nE) Write Done이 안됬어도 미리 Ack를 보낼지 안보낼지에 대한것.\n메모리 Write는 Error가 안날 확률이 매우 높기떄문에 이렇게 처리한다는듯.\n ARM에서 사용하는 Device Type Device-nGnRnE. Stronlgy Ordered Memory. 다 안쓴다느듯.\nDevice-nGnRE Early Ack만 쓰겠다는뜻.\nDevice-GRE 모든 버퍼를 쓰겠다는뜻.\n"},{"id":4,"href":"/linux_arm64_kernel/memory/cache/","title":"Cache","parent":"Linux_arm64_kernel","content":"참고사이트 문c블로그 Cache-Coherent\n Cache Policies Cache Allocation Policies WA, RA(Write-Allocate, Read-Allocate)   Write시 Cache에 해당 메모리가 없을때(Miss발생시)\n Cache에 해당 메모리의 데이터를 할당. 할당된 캐시에 데이터를 기록한다.    Write시 Cache에 해당 메모리가 존재할때\n RAM에 접근하지않고 Cache에만 접근하고 끝날것이다.    cache data는 dirty, memory data는 old가 될것이다.\nRead또한 마찬가지로 read시 cache에 없으면 cache에 할당한다.\n꽤 많은 블로그에서 WA에대 잘못설명한다.\nCache에 할당하지 않고 바로 Memory에 Write 하기때문에 WT랑 같이 사용하지 않는다는둥, 대부분의 시스템에서는 WT nWA를 사용한다는둥..\nWA는 DRAM의 Data를 old로 만들고 cache write(dirty)를 하는거다.. miss일때 최초 한번만 DRAM에 접근한다는 얘기다.\nLinux만 놓고 봤을때도 WT의 default는 WA이다\u0026hellip;ㅋㅋ linux말고 대부분이 WT nWA를 쓰나?\nCache Write Pollicies WB(Write-Back)   Write\n Cache에만 Write. cache가 가득 찻을때만 Memory에 Write    Read\n Cache에서만 읽음    WT(Write-Through)   Write\n Cache, Memory 둘다 Write    Read\n Cache에서만 읽음    Cache Allocation + Write Pollicies Cache Allocation Policies는 Cache Write시 Miss가 됬을때 Cache Allocate를 할건지에 대한 정책이고\nCache Write Policies는 Write DRAM에도 Write를 하는 정책이다.(Read는 무조건 miss면 DRAM에서 가져오는거니 모든 정책에서 같다)\n즉 둘을 나눠서만 생각하면 된다.\nWrite시 DRAM에도 쓰고 싶으면 WT, Cache만 읽을거면 WB Write시 Miss가 났을때 Cache에 할당할거면 WA, 아니면 nWA다.\nARMv8에서의 Cache Policies Normal Memory에서는 WTWA만을 사용하는데, TTB관련은 WBWA를 쓰는것처럼 보인다.\n Shareability 아키텍처에서 공유라는것은 CPU를 기준으로 의미한다.\nInner CPU : Linux로 동작하는 모든 시스템 Outer CPU : Linux를 사용하지 않는 시스템(ex GPU)\n Cache Type [참고사이트] (https://aidanbae.github.io/code/devops/computer/cpucache/)\nDirect-mapped cache [참고사이트] (https://talkingaboutme.tistory.com/entry/Study-Memory-Hierarchy-2-Direct-Mapped-Cache)\ncache구조를 설명할때 그냥 이렇게 동작한다라고 알려주는게 바로 이 방식. tag, index를 모두 사용하여 특정 cache address가 여러개의 dram address를 커버하게 되는 구조이다.\nFully associative cache 그냥 아무데나 넣고, 찾을때는 전부 검색해서 찾는 방식.\nN-way-set-associative cache Block화 하고 그것을 index화 하는 방식으로 fully와 direct방식을 혼합한 거라고 한다.\nARMv8에서 의 Cache Type.  ARM Ref.11.1.1 Set associative caches and ways 참고  Cortex에 따라 달라지는거 같은데 L1 Data cache은 4way, L1 Instruction cache는 2 Way,\nL2는 16way, L3은 더 많은 way등을 가질수있다고 한다.\n또한 MMU TLBs의 경우를 제외하곤 Way를 늘리는것에 대해 추천하지 않는다고 한다.\nMMU TLBs와 같이 매우 작은 cache에 대해서는 Way를 늘리는게 도움이 된다고 하며, 8방향이 minimum이라고 하며, L2 같이 큰 cache에서만 유용하다는듯 싶다\n Cache terminology Way Cache Type을 set-associative로 사용할때 나오는 용어로, 몇개의 line을 1개의 block. 즉 way로 썻냐는것이다.\n1 way면 direct mapped와 같은거나 다름없고, way가 총 line수와 같으면 fully와 똑같다.\nCache의 용량 Cache의 용량을 말할때는 Line의 크기만을 두고 말한다.\nCache data는 크게 Line, tag로 이루어져있는데 흔히 4k cache등을 말할때는 저 cache data의 구조에서 Line + tag등의 data 전체 크기가 아니라 오로직 Line크기만을 다 합친것을 의미한다.\nSt.B(Store buffer) / Write buffer cpu -\u0026gt; store buffer -\u0026gt; cache -\u0026gt; wirte buffer -\u0026gt; memory\nAXI(Advanced eXtensible Interface) [참고사이트] (https://m.blog.naver.com/esoclab/20174360379)\ncache -\u0026gt; dram 의 사이에서 사용하고 있는 있는 bus.\nAXI를 설명할때 AHB와 비교를 많이하는데, AXI는 채널이라는게 도입됬다고 한다.\n기존 버스라는 개념은 예를들어 A(저속 디바이스), B(고속 디바이스)요청이 있을때\nA주소 전송 -\u0026gt; Adata 받음(B는 기다려야함)\n을 기다려야 됬는데 채널이라는 개념이 도압되면서\n1채널에 A주소 전송, 2채널에 B주소 전송이 가능해 진다는것 같다.\n또한 버스트 전송이 기본개념이라 버스트 전송을 전제로 동작한다고 한다.\ndata 전송 단위는 bit이며 8, 16, 32, 64 \u0026hellip; 1024 bit등을 지원하는거 같다.\nSCU(Soope control unit) 어떤 CPU에서 해당 CPU의 L1 Cache miss data를 L2에 요청했을때 해당 data가 다른 CPU cache에 해당 값이 존재하는지, 존재한다면 해당값을 전송하는 역할을 한다.\n Cache 전송 예제 Cache Data 1 byte read 시 다음의 전제를 가진다.\n cache line 크기 : 16bit 크기의 cache line AXI 전송단위 : 8bit  cache line의 최소크기인 16bit인데 1byte만을 가져올순없다. 그래서 cache line의 최소크기인 16bit로 읽는다. 이때 AXI 전송단위가 8bit이므로 2번을 읽어야되는데, AXI구조상 start address와 length를 주면 해당 값만큼 읽어오는 개념인가보다. 그래서 그렇게 한번의 주소+크기 요청으로 데이터를 가져온다.\ncpu \u0026lt;-\u0026gt; 메모리의 데이터 전송 단위 cpu -\u0026gt; (가상메모리 cache) -\u0026gt; mmu -\u0026gt; (물리메모리 cache) -\u0026gt; memory\ncpu \u0026lt;-\u0026gt; cache : 1byte or 4byte\ncache \u0026lt;-\u0026gt; cache : cache line단위\ncache memory \u0026lt;-\u0026gt; DRAM : AXI bus 단위\n큰그림 cpu A \u0026lt;-\u0026gt; st.b \u0026lt;-\u0026gt; L1 cache \u0026lt;-\u0026gt; | | cpu B \u0026lt;-\u0026gt; st.b \u0026lt;-\u0026gt; L1 cache \u0026lt;-\u0026gt; | S | cpu C \u0026lt;-\u0026gt; st.b \u0026lt;-\u0026gt; L1 cache \u0026lt;-\u0026gt; | C | \u0026lt;-\u0026gt; L2 cache \u0026lt;-\u0026gt; Memory cpu D \u0026lt;-\u0026gt; st.b \u0026lt;-\u0026gt; L1 cache \u0026lt;-\u0026gt; | U |\n\u0026hellip; Instruction cache. Instruction cache는 dirty bit가 존재하지 않는다.\n TLB(Translation Lookaside Buffer) 가상주소를 물리주소로 변환하는 속도를 높이기 위해 사용하는 캐시.\n Cache maintance [참고사이트] (https://ko.wikipedia.org/wiki/%EC%BA%90%EC%8B%9C_%EC%9D%BC%EA%B4%80%EC%84%B1)\nCPU간 Cache 일관성을 지켜야하는데, 이 지키는 범위를 정해논게 PoC, PoU라고한다.\nCPU간 각자의 cache가 변했다는걸 확인하는게 스누핑 이라는 구조고, (MOESI라는 프로토콜을 쓴다는듯)\n이걸 통해서 CPU간의 일관성을 확인한다고한다.\nSnooping 주소 버스를 항상 감시하여 캐시 상의 메모리에 대한 접근이 있는지를 감소하는 구조.\n다른 캐시에서 쓰기가 발생하면 캐시 컨트롤러에 의해서 자신의 캐시 위에 있는 복사본을 무효화시킨다.\nPoc(Point of Coherency) DMA, DSP등의 외부 Device와 Coherency를 맞추기 위한 개념으로 DRAM까지 Coherency를 맞추는다는것.\nPoU(Point of Unification) 캐시 일관성을 Data Cache뿐만 아니라 Instruction Cache까지 지킨다는 것.(+Translation Table Walk)\nARMv8에서의 Poc, PoU linux에서는 미리 정해진 PoC, PoU에 따라 Cache Clean을 하는 명령어가 정해져있다.\nInstruct Cache같은경우엔 PoU 밖에 존재하지 않는데, Data Cache는 빈번하게 바뀔 여지가 있지만 Instruct Cache를 교체하는 경우가 빈번하지 않고 교체하게 되면 결국 Data Cache까지 바뀌게 되는 개념이므로 PoU만 존재하는것처럼 보인다.\nLoC(Level of Coherence) PoC, PoU가 추상적인 개념이라면, 실제 Arch에 명령어를 날려야할때 몇번 Level까지 수행인지를 정해야된다. PoC를 수행할 Last Cache에 대한 Level을 의미한다.\nLoUU(Level of Unification, Uniprocessor) 단일 Process에서 PoU를 수행할 Last Cache에 대한 Level을 의미한다.\nLoUIS(Level of Unification, Inner Shareable) 공유 자원에 대한것에 대해서의 Last Cache에 대한 Level을 의미한다. SMP 에서만 존재한다. 단일 Process는 LOUU, SMP는 LoUISf라고만 일단 이해하고 넘어가야겠다.\n"},{"id":5,"href":"/linux_arm64_kernel/arch/TCR/","title":"TCR","parent":"Linux_arm64_kernel","content":"TXSZ 가상주소를 계산할때 상위 주소의 0, 1의 개수를 미리 설정해놓는것이다. Kernel 공간 인경우 상위 비트가 1이 채워져있는 개념이므로 T1SZ을 사용하게 되고 user 공간 인경우 상위 비트가 0이 채워져있는 개념이므로 T0SZ을 사용하게 된다.\n T0SZ User 공간의 가상주소에서 주소 하위에서부터 0이 채워지는 비트 개수\n T0SZ = 16일때 0x0000_ABCD_ABCD_ABCD__ABCD_ABCD_ABCD   T1SZ Kernel 공간의 가상주소에서 주소 상위에서부터 1이 채워지는 비트 개수\n T1SZ = 16일때 0xFFFF_ABCD_ABCD_ABCD__ABCD_ABCD_ABCD_ABCD   특성  TXSZ가 커짐에따라 해당 영역의 가상주소공간이 줄어듬을 알 수 있다. 한번 정해지면 바귀지 않는다.   TGX(Translation Granule 0, 1)\nMemory Mapping 단위를 Granule Size라고 하는데 user, kernel 각각의 memory mapping size에 대한 내용\n4KB, 16KB, 64KB설정이 가능한듯.\n"},{"id":6,"href":"/linux_arm64_kernel/assembly/ifb/","title":"Ifb","parent":"Linux_arm64_kernel","content":"[ifb 참고] (https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/useful-assembler-directives-and-macros-for-the-gnu-assembler)\n .macro\tldr_l, dst, sym, tmp= .ifb\t\\tmp adrp\t\\dst, \\sym ldr\t\\dst, [\\dst, :lo12:\\sym] .else adrp\t\\tmp, \\sym ldr\t\\dst, [\\tmp, :lo12:\\sym] .endif .endm .ifb = if blank라는 뜻\nldr_l\tx4, idmap_ptrs_per_pgd 이런 코드가 왔으면 위 macro에서 ifb 로 된 code가 만들어질것이다. "},{"id":7,"href":"/linux_arm64_kernel/instruction/dc/","title":"DC","parent":"Linux_arm64_kernel","content":"data cache 의 invalidate / clean 관련 명령어\n cache invalidate한다 라는 의미는? cache clean한다 라는 의미는? dirty bit가 set된 cache를 모두 메모리에 반영한다는것.\ndc ivac, Xt D-cache invalidate by address to Point of Coherency\ndc instruction option에 대한 설명   dc : Data Cache\n  IC : Instruction Cache\n  IS : Inner Shareable\n  ALL : all\n  U : Point of Unification\n  VA : Address to Point of Coherency\n  Z : zero\n  SW : Set/Way\n  I : invalidate\n  C : Clean / Point Coherency\n   "},{"id":8,"href":"/linux_arm64_kernel/instruction/dmb/","title":"DMB","parent":"Linux_arm64_kernel","content":"해당 instruction을 기준으로 명령의 순서를 변경하지 않는다.\n dmb sy Ordered Accesses : Any - Any\nstore / load가 전부 완료될때까지 기다리고 하겠다는뜻.\n "},{"id":9,"href":"/git/","title":"Git","parent":"Test1234가나다라","content":""},{"id":10,"href":"/Git/SSH-Key-Setup/","title":"SSH Key Setup","parent":"Git","content":"ubuntu 환경을 기준으로 한다.\n 자신의 ssh key 생성. ssh-keygen 처음 물어보는게 key의 경로이자 name이 된다. 그냥 넘기면 기본 경로로 ~/.ssh/id_rsa, ~/.ssh/id_rsa.pub에 존재한다.\n~/.ssh/id_rsa : private key ~/.ssh/id_rsa.pub : public key\npublic key를 github자신의 계정에 등록해줘야한다.\ncat ~/.ssh/id_rsa.pub 하면 쏼라쏼라 나올텐데 전부 copy해놓는다.\n자신의 github 에 ssh키 등록 github 계정에서 setting -\u0026gt; SSH and GPG keys에 들어가서 New SSH key 눌러서 등록한다.\nclone 한 repository remote 경로 변경 일반적으로 그냥 copy해서 가져오면 remote경로가 https://\u0026hellip; 로 시작한다. 이러면 결국 웹 프로토콜로 통신을 하므로 이렇게 해서는 안되고 scp로 접근하는것처럼 바꿔줘야한다.\n일단 다음의 명령어로 어디에 remote 되있는지 보고\ngit remote -v git remote set-url origin git@github.com:prifri/prifri.github.io.git 뭐 이런식으로 바꿔줘야한다.\n다중 SSH key 셋팅. 사이트\n"},{"id":11,"href":"/Make_Site/Hugo%EB%A1%9C-site-%EB%A7%8C%EB%93%A4%EA%B8%B0/","title":"Hugo로 site 만들기","parent":"Make_Site","content":"  Site BootUp  Hugo 설치 사이트 테마 다운로드 repository 관리. workspace repository 연동 repository 관리. build repository 연동   Comment 생성 구글, Naver 검색에 사이트 노출 시키기  sitemap 생성 robot.txt 생성 google 검색에 사이트 노출 시키기  sitemap 인식이 안될경우 (사이트맵을 읽을 수 없음)   naver 검색에 사이트 노출 시키기  site 체크     md 좀더 편하게 작성하기.  stackedit     ubuntu 환경을 기준으로 한다.\n Site BootUp Hugo 설치 Hugo 에 대한 설명과 설치\nHugo 공식 Quick Start\nubuntu에서 환경을 시작하므로 apt로 hugo를 설치한다.\nsudo apt-get install hugo 사이트 site 이름은 prifri_site 라고 대충 정했을때\n다음과 같은 명령어로 site 환경을 초기화한다.\nhugo new site prifri_site cd prifri_site directiory가 생기고 해당 directory가 workspace 개념이된다.\n테마 다운로드 Hugo Themes\nGeekdocs\ngeekdoc를 사용했다. darkmode가 바로 지원되는게 마음에 들어 그냥 이거썻다.\ncode study용 블로그는 주로 doc계열을 많이 사용하는거 같으며 대표적으로 learn, books등이 존재하는거 같다.\n생성방법은 Geekdocs의 공식 started를 따른다.\nmkdir -p themes/hugo-geekdoc/ curl -L https://github.com/thegeeklab/hugo-geekdoc/releases/latest/download/hugo-geekdoc.tar.gz | tar -xz -C themes/hugo-geekdoc/ --strip-components=1 config.toml을 공식 홈페이지에서 요구하는것처럼 똑같이 수정해준다.\nnpm으로 뭘 이것저것도 잇는데 Geekdocs 테마의 original source를 build하는게 아니면 필요없다.  repository 관리. workspace repository 연동 repository 가 2개 필요하다. 한개는 site의 모든 source가 있을 workspace가 존재하는 repository와 build 결과물만이 존재해 실제 site와 연동되는 repository가 필요하다.\n실제 site와 연동되는 repository는 git 계정이름을 사용해서 다음과 무조건 ${NAME}.github.io로 이름을 지어야되며, 무료사용자일 경우 무조건 public으로 써야된다.\nbuild 결과물 repository는 workspace repository의 submodule로 사용할 것다.\n아마 다른 directory에 관리하는 방법으로도 되긴 하겠지만 빌드 결과물이 생기는 public directory그 자체는 바로 git repository로 쓰는게 편한방법이라 다들 이렇게 그냥 쓰는거 같다.\n일단 github에서 workspace(hugo site 생성명령어로 만들어진 directory)용 repository와 build repository를 만든다.\n그리고 site directory를 workspace repository로 remote 시켜준다. prifri_site로 예로 들면 다음과 같다.\ngit init git remote add origin git@github.com:prifri/prifri_site.git https://github.. 은 현재 시점에서 이제 사용하지 않는다 auth token을 써야 되는데 매번 번거로우므로 github 계정에 ssh key를 등록시켜놓는 방법으로 사용한다.\nrepository 관리. build repository 연동 현재 빌드를 한번도 안했기 때문에 build에 대한 결과물이 없으므로 빌드를 한번 해준다.\nhugo -t hugo-geekdoc 그러면 public directory가 생기는데 이것을 이제 build repository와 연결을 해줘야된다.\nworkspace repository source안에 build repository가 있는 개념이므로 submodule로 연동해준다.\ngit submodule add -b origin git@github.com:prifri/prifri.github.io public 그후 workspace, build repository둘다 git add 후 push로 밀어보면 적당히 보이고 config.toml을 적당히 수정해서 적당히 content 만들고 해보면된다.\nComment 생성 utteranaces를 사용했다.\n참고사이트\nscript 복사를 하는곳은 지금 사용하고있는 Geekdocs 기준으로\nlayouts/partials/page-footer.html 의 밑에 넣었더니 main page에서도 나오더라. 아마 모든 page의 아래에 대한 html인가 보다.\nrepository는 무조건 public으로 해야된다. private로 하면 동작안한다.\n구글, Naver 검색에 사이트 노출 시키기 sitemap 생성 자동생성이 기본이지만 config.toml에서 sitmap 파라미터란것도 존재하는듯 싶다. 참고사이트\n# sitemap 생성 [sitemap] changefreq = \u0026#34;monthly\u0026#34; filename = \u0026#34;sitemap.xml\u0026#34; priority = 0.5 robot.txt 생성 config.toml에 roboot.txt 자동생성 기능을 추가한다. [markup] 이나 [param]같은 것 아래에서 하면 안된다.\n참고사이트\n# robots.txt enableRobotsTXT = true google 검색에 사이트 노출 시키기 참고사이트 public 에 넣고 push후 좀 기다리고나서 인증요청하면된다.\nsitemap 인식이 안될경우 (사이트맵을 읽을 수 없음) 시간이 지나면 된다고 하는 경우가 있다. 나도 안되서 그냥 적당히 하다가 포기했다. 참고사이트\nnaver 검색에 사이트 노출 시키기 네이버 웹마스터가 네이버 서치어드바이저로 변경된듯 싶다.\ngoogle에 등록했을때랑 똑같이 html 파일을 받아서 public에 넣어놓는다.\nrobots.txt 설정도 공홈에서 제공해주는 웹마스터 가이드를 보면 자세히 나와있다.\n그리고 google에서 인증할때와 마찬가지로 naver에서도 html을 가져와야된다.\nsite 체크 site check에 들어가서 확인해본다.\nmd 좀더 편하게 작성하기. stackedit 참고사이트 stackedit\n"},{"id":12,"href":"/make_site/","title":"Make_Site","parent":"Test1234가나다라","content":""},{"id":13,"href":"/categories/","title":"Categories","parent":"Test1234가나다라","content":""},{"id":14,"href":"/tags/","title":"Tags","parent":"Test1234가나다라","content":""}]